# 数组

Python中内置类型列表list用以实现动态数组。

像在Python这样的更现代的高级语言中，已经越来越避免让程序员主动去指定一个类似数组这样的数据结构的长度，以由此决定对相应对象的内存分配。这个工作已经被语言给封装好，使得程序员编码更加方便自由，同时也规避了很多来源于内存或是指针相关的错误和陷阱。

当然内存的硬件组织并没有发生根本性的改变，在底层显式地指定一段序列的长度和单位大小依然是准确分配和使用内存空间的必需。这对Python中的那些不可变类型的对象，比如：字符串（str）和元组（tuple），并不会产生问题，因为这些对象一旦初始化在内存中便是固定的。但是，列表（list）允许不断地在现有列表上添加删除和修改其元素，显然长度的不断变化不能由指定长度的内存空间满足，为此引入了动态数组（dynamic array）的概念。

动态数组其实在底层同样是建立在一段连续的内存空间上，由指定长度的静态数组（内存空间）来实现数据存储和读取的，只是通常这个静态数组的容量会大于列表现有元素的长度。这样在大多数情况下，向列表添加元素的操作就和传统的方式一样，在指定长度的静态数组中下一个空位添加该元素即可。

如果不断向上述的静态数组中添加新元素，迟早静态数组保留的多余空间也会被占满。当空间被耗尽时，列表（动态数组）不同于静态数组，将向系统申请一个更大的静态数组。然后，列表将会将之前的静态数组的内容复制到新的更大的静态数组中去。此时，原来的静态数组便没有存在的价值，而可由系统回收作垃圾收集，因为数据已经被转移保存到新的更大的静态数组中去了。

![寄居蟹](http://drawingimage.com/files/2/Hermit-Crab-Drawing-Pic.png)

由动态数组实现的列表其实可以看做是一个寄居蟹，而它所依赖的静态数组则可以看做是固定大小的贝壳。寄居蟹总是找到那些能投容纳它身体的贝壳栖身，而当身体长大难以被现有贝壳容纳时，则需要寻找更大更宽敞的贝壳来当做新家。这边是更现代的高级语言脱离像C语言的内存指定方式，而迈向更灵活高效并且不易出错的动态数组的基本原理。

列表list的行为主要可以分为与元组tuple类似的不可变（immutable）行为和自身特有的可变（mutable）行为，主要区分在于行为是否改变列表内容。

关于列表元素的反转，在题目[Code Jam #Reverse Words](https://wulei.me/2017/02/21/code-jam-reverse-words/)中讨论了几种常见的常见的反转方式及其特点。

```python
words = line.split(' ')
words.reverse() # in-place
words_2 = reversed(words) # new object
words_3 = words[::-1] # shallow copy
words_4 = []
for i in range(len(words)):
	words_4.append(words.pop()) # iteratively append
```

其中`.reverse()`实现的是就地反转，对需要保留原数据的情况不适用。`reversed()`方法则产生新的对象，原列表不会受影响。本文采用的切割方式则返回的是原列表元素的浅度复制（shallow-copy），即新旧列表的元素都是对相同内容的引用，修改其中任意一个，都会对另一个产生影响。此种方式对于不可变的（immutable）字符串则可放心大胆使用，因为反正也无法修改内容。最后一种多是在要求不使用内置方法时使用。

具体可参见[文档](https://docs.python.org/3/tutorial/datastructures.html)。