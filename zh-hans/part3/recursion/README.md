# 递归问题

许多复杂的问题都可以将其分解为规模更小的子问题进行分析解决。如果分解后的子问题除了规模缩小，其求解方式与原始问题存在结构上的一致性，那么通常可以使用递归的方式进行求解。所谓**递归**的策略，具体而言指的是一个函数（方法）在执行过程中（一次或多次）调用自身；或者一种数据结构依赖于同一种数据结构的更小规模的实例构成（比如树tree）。显见，子问题与原问题的同构性乃是递归适用的前提和特征。递归的本质在于利用问题与其子问题结构的类似乃至重复，针对相同结构做出分析解决，从而将待解决的问题不断分解，并且实现代码复用。一般来讲递归的算法的可读性也较高，利于理解。比如在有序序列`data`中查找目标`target`是否存在的二分搜索的一个递归实现，如下：

```python
def binary_search(data, target, low, high):
	if low > high:
		return False 
	else:
		mid = (low + high) // 2
		if target == data[mid]:
			return True
		elif target < data[mid]:
			return binary_search(data, target, low, mid − 1)
		else:
			return binary_search(data, target, mid + 1, high)
```

递归的方式可以是从底向上（bottom-up），自顶向下（top-down）或是二分发的方式等，把原始问题划分为子问题。从底向上意味着从最基本且易于求解的情况考虑问题，然后一步步增加考虑的元素，并在此前结果的基础上进行处理以求解当前情况，颇与数学归纳法类似。而自顶向下的思路则直接分析原问题（比如输入规模为`n`）如何转化对规模稍减的子问题（比如输入规模为`n-1`）的求解。二分法则通常考虑是否能将输入集直接划分为对称或几乎相近的两个组，这样有时能很迅速地缩减问题规模至可直接求解的基本情况。

递归问题的运行时间分析的关键在于原问题与子问题关系的分析。递归树(recursion trace)能够简洁地刻画这种关系，并且有利于从递归树的结构（线性或者分支等）归纳出递归过程步骤与输入规模的定量关系。考虑递归分支的数量以及其中每一分支的非递归部分的运行时间进行，进行加总即可以得出总得运行时间，进行渐进分析（比如`O(n)`等）。

递归算法的设计由以上分析可知主要包括基本情况（base case）的求解，以及原问题到子问题的递归过程。其中基本情况的求解要求直接与全面，这意味着所有更复杂的情况，经过递归后必然能够退化为基本情况（之一）进行求解。而递归过程则必须保证问题向基本情况的方向而非相反退化。

另一个值得注意的策略则是设计递归算法的解决方案的参数化。很多求解（函数）显式的结构（其函数签名或参数列表）并不一定有利于设计递归算法，这是因为此时难以归纳出子问题与之有类似结构。此时如果人为显式地重新定义原问题的求解函数，提供更多体现原问题当前状态的参数不失为一种方法。这样做的好处是重新定义了问题，提供私有的功能函数(non-public utility function)，以使原问题和所有子问题都具有完全相同的问题结构和函数签名（参数列表）。与此同时，在最外层的求解函数仍然对用户提供了简洁的公共接口（public interface），使之毋须在调用外层函数时考虑手动设置参数。比如前文的`binary_search`可以作为一个原问题和子问题共同使用的功能函数，因为参数`low`和`high`的出现使其具有了相同的结构，同时又能在参数的变化上体现问题的递归分解。而这个函数可以由另一个外层函数，甚或`data`对象的方法等来调用，作为外部接口。

递归调用的过程会导致编译器存储当前和此前所有嵌套函数的相关状态，导致对内存的占用不断增加。将这些中间结果转化为栈（stack）中的数据可在一定程度上减小由编译器带来的内存开销。不少迭代问题可以转化为非递归的迭代循环结构来求解问题。特殊的递归比如部分线性递归和所谓尾部递归（tail recursion），被证明一定可以转化为非递归的循环结构来实现。尾部递归指递归调用都发生在当前环境执行指令的最后一步，并且立即返回递归调用的结果作为当前环境的返回结果，完成后不会再有其他操作。线性递归指一次递归至多产生一次新的调用的递归。显然尾部递归必然是线性递归。尾部递归和部分递归转化为非递归的循环结构，通常是利用讲循环调用的动作用对循环结构的参数在循环体中进行重新赋值更新来实现。

具体倒上面二分搜索的例子，如果用循环实现如下：

```python
def binary_search(data, target):
	low = 0
	high = len(data)−1
	while low <= high:
		mid = (low + high) // 2
		if target == data[mid]:
			return True
		elif target < data[mid]:
			high = mid − 1
		else:
			low = mid + 1
	return False
```

对比可以看出循环中对参数`low`和`high`的不断更新赋值替代了递归调用中对子问题的触发，两者在功能实现上是等效的。